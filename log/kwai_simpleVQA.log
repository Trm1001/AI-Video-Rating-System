C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
{'name': 'SimpleVQA', 'num_epochs': 5, 'l_num_epochs': 0, 'warmup_epochs': 2.5, 'ema': True, 'save_model': True, 'batch_size': 4, 'num_workers': 6, 'data': {'train': {'type': 'ViewDecompositionDataset_add_forSimpleVQA', 'args': {'weight': 0.54, 'phase': 'train', 'anno_file': 'C:/Project/KVQ/KVQ-Challenge-CVPR-NTIRE2024/Train/train_data - 1.csv', 'data_prefix': 'C:/Project/KVQ/KVQ-Challenge-CVPR-NTIRE2024/Train', 'data_prefix_3D': 'C:/Project/KVQ/KVQ-Challenge-CVPR-NTIRE2024/feature/simpleVQA/kvq', 'feature_type': 'SlowFast', 'sample_types': {'simpleVQA': {'resize': 520, 'crop': 448, 'clip_len': 8, 'frame_interval': 10, 't_frag': 8, 'num_clips': 1}}}}, 'val': {'type': 'ViewDecompositionDataset_add_forSimpleVQA', 'args': {'phase': 'test', 'anno_file': 'C:/Project/KVQ/KVQ-Challenge-CVPR-NTIRE2024/Train/train_data - 1.csv', 'data_prefix': 'C:/Project/KVQ/KVQ-Challenge-CVPR-NTIRE2024/Train', 'data_prefix_3D': 'C:/Project/KVQ/KVQ-Challenge-CVPR-NTIRE2024/feature/simpleVQA/kvq', 'feature_type': 'SlowFast', 'sample_types': {'simpleVQA': {'resize': 520, 'crop': 448, 'clip_len': 8, 'frame_interval': 10, 't_frag': 8, 'num_clips': 1}}}}}, 'model': {'type': 'simpleVQA', 'args': {'simpleVQA': {'backbone': None, 'head': {'in_channels': 9472, 'hidden_channels': 128}}}}, 'optimizer': {'lr': 3e-05, 'backbone_lr_mult': 1.0, 'wd': 0.05}, 'load_path': 'checkpoint\\SimpleVQA_epoch_6_head_val-ltest_s_finetuned.pth', 'test_load_path': 'checkpoint\\SimpleVQA_epoch_6_head_val-ltest_s_finetuned.pth'}
simpleVQA branch sampled frames: [ 0  5 10 15 20 25 30 35]
simpleVQA branch sampled frames: [ 0  5 10 15 20 25 30 35]
load from pretraimed resnet: <All keys matched successfully>
Setting backbone: simpleVQA_backbone
Setting head: simpleVQA_head
C:\Project\kvq2\kvq\trainer.py:62: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(self.config["load_path"], map_location=self.device)
模型总参数数量: 25933378
<All keys matched successfully>
End-to-end Epoch 0:
Training in epoch 0:   0%|          | 0/25 [00:00<?, ?it/s]Training in epoch 0:   4%|         | 1/25 [01:17<30:51, 77.15s/it]Training in epoch 0:   8%|         | 2/25 [01:35<16:15, 42.42s/it]Training in epoch 0:  12%|        | 3/25 [01:53<11:33, 31.52s/it]Training in epoch 0:  16%|        | 4/25 [02:12<09:16, 26.49s/it]Training in epoch 0:  20%|        | 5/25 [02:30<07:51, 23.55s/it]Training in epoch 0:  24%|       | 6/25 [02:49<06:56, 21.92s/it]Training in epoch 0:  28%|       | 7/25 [03:07<06:12, 20.67s/it]Training in epoch 0:  32%|      | 8/25 [03:25<05:35, 19.74s/it]Training in epoch 0:  36%|      | 9/25 [03:43<05:06, 19.14s/it]Training in epoch 0:  40%|      | 10/25 [04:00<04:40, 18.67s/it]Training in epoch 0:  44%|     | 11/25 [04:19<04:18, 18.48s/it]Training in epoch 0:  48%|     | 12/25 [04:37<04:01, 18.57s/it]Training in epoch 0:  52%|    | 13/25 [04:55<03:40, 18.39s/it]Training in epoch 0:  56%|    | 14/25 [05:13<03:19, 18.12s/it]Training in epoch 0:  60%|    | 15/25 [05:31<03:00, 18.02s/it]Training in epoch 0:  64%|   | 16/25 [05:48<02:41, 18.00s/it]Training in epoch 0:  68%|   | 17/25 [06:06<02:23, 17.89s/it]Training in epoch 0:  72%|  | 18/25 [06:24<02:04, 17.81s/it]Training in epoch 0:  76%|  | 19/25 [06:41<01:46, 17.71s/it]Training in epoch 0:  80%|  | 20/25 [06:59<01:28, 17.70s/it]Training in epoch 0:  84%| | 21/25 [07:17<01:11, 17.78s/it]Training in epoch 0:  88%| | 22/25 [07:35<00:53, 17.75s/it]Training in epoch 0:  92%|| 23/25 [07:52<00:35, 17.68s/it]Training in epoch 0:  96%|| 24/25 [08:10<00:17, 17.61s/it]Training in epoch 0: 100%|| 25/25 [08:27<00:00, 17.62s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Training in epoch 0: 100%|| 25/25 [08:32<00:00, 20.52s/it]
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:44<1:14:12, 44.98s/it]Validating:   2%|         | 2/100 [00:46<31:40, 19.40s/it]  Validating:   3%|         | 3/100 [00:47<18:06, 11.20s/it]Validating:   4%|         | 4/100 [00:49<11:48,  7.38s/it]Validating:   5%|         | 5/100 [00:50<08:19,  5.26s/it]Validating:   6%|         | 6/100 [00:52<06:11,  3.95s/it]Validating:   7%|         | 7/100 [00:53<04:51,  3.14s/it]Validating:   8%|         | 8/100 [00:55<03:58,  2.59s/it]Validating:   9%|         | 9/100 [00:56<03:22,  2.23s/it]Validating:  10%|         | 10/100 [00:58<03:02,  2.03s/it]Validating:  11%|         | 11/100 [00:59<02:46,  1.87s/it]Validating:  12%|        | 12/100 [01:01<02:33,  1.75s/it]Validating:  13%|        | 13/100 [01:02<02:24,  1.66s/it]Validating:  14%|        | 14/100 [01:04<02:16,  1.59s/it]Validating:  15%|        | 15/100 [01:05<02:11,  1.54s/it]Validating:  16%|        | 16/100 [01:07<02:07,  1.52s/it]Validating:  17%|        | 17/100 [01:08<02:05,  1.51s/it]Validating:  18%|        | 18/100 [01:09<02:02,  1.50s/it]Validating:  19%|        | 19/100 [01:11<02:00,  1.48s/it]Validating:  20%|        | 20/100 [01:12<02:00,  1.51s/it]Validating:  21%|        | 21/100 [01:14<01:57,  1.49s/it]Validating:  22%|       | 22/100 [01:15<01:55,  1.49s/it]Validating:  23%|       | 23/100 [01:17<01:56,  1.51s/it]Validating:  24%|       | 24/100 [01:18<01:53,  1.50s/it]Validating:  25%|       | 25/100 [01:20<01:52,  1.50s/it]Validating:  26%|       | 26/100 [01:21<01:48,  1.47s/it]Validating:  27%|       | 27/100 [01:23<01:47,  1.47s/it]Validating:  28%|       | 28/100 [01:24<01:45,  1.46s/it]Validating:  29%|       | 29/100 [01:26<01:42,  1.45s/it]Validating:  30%|       | 30/100 [01:27<01:40,  1.44s/it]Validating:  31%|       | 31/100 [01:28<01:38,  1.42s/it]Validating:  32%|      | 32/100 [01:30<01:35,  1.40s/it]Validating:  33%|      | 33/100 [01:31<01:33,  1.40s/it]Validating:  34%|      | 34/100 [01:33<01:32,  1.41s/it]Validating:  35%|      | 35/100 [01:34<01:31,  1.41s/it]Validating:  36%|      | 36/100 [01:35<01:30,  1.42s/it]Validating:  37%|      | 37/100 [01:37<01:30,  1.43s/it]Validating:  38%|      | 38/100 [01:38<01:30,  1.46s/it]Validating:  39%|      | 39/100 [01:40<01:29,  1.46s/it]Validating:  40%|      | 40/100 [01:41<01:28,  1.47s/it]Validating:  41%|      | 41/100 [01:43<01:26,  1.46s/it]Validating:  42%|     | 42/100 [01:44<01:24,  1.46s/it]Validating:  43%|     | 43/100 [01:46<01:23,  1.47s/it]Validating:  44%|     | 44/100 [01:47<01:23,  1.48s/it]Validating:  45%|     | 45/100 [01:49<01:19,  1.45s/it]Validating:  46%|     | 46/100 [01:50<01:17,  1.43s/it]Validating:  47%|     | 47/100 [01:51<01:15,  1.42s/it]Validating:  48%|     | 48/100 [01:53<01:13,  1.42s/it]Validating:  49%|     | 49/100 [01:54<01:11,  1.41s/it]Validating:  50%|     | 50/100 [01:56<01:10,  1.40s/it]Validating:  51%|     | 51/100 [01:57<01:08,  1.40s/it]Validating:  52%|    | 52/100 [01:59<01:07,  1.41s/it]Validating:  53%|    | 53/100 [02:00<01:06,  1.42s/it]Validating:  54%|    | 54/100 [02:01<01:05,  1.42s/it]Validating:  55%|    | 55/100 [02:03<01:04,  1.44s/it]Validating:  56%|    | 56/100 [02:04<01:03,  1.45s/it]Validating:  57%|    | 57/100 [02:06<01:03,  1.47s/it]Validating:  58%|    | 58/100 [02:07<01:01,  1.46s/it]Validating:  59%|    | 59/100 [02:09<00:59,  1.44s/it]Validating:  60%|    | 60/100 [02:10<00:56,  1.42s/it]Validating:  61%|    | 61/100 [02:11<00:54,  1.40s/it]Validating:  62%|   | 62/100 [02:13<00:52,  1.39s/it]Validating:  63%|   | 63/100 [02:14<00:51,  1.39s/it]Validating:  64%|   | 64/100 [02:16<00:49,  1.38s/it]Validating:  65%|   | 65/100 [02:17<00:48,  1.37s/it]Validating:  66%|   | 66/100 [02:18<00:46,  1.38s/it]Validating:  67%|   | 67/100 [02:20<00:46,  1.40s/it]Validating:  68%|   | 68/100 [02:21<00:44,  1.40s/it]Validating:  69%|   | 69/100 [02:22<00:42,  1.39s/it]Validating:  70%|   | 70/100 [02:24<00:41,  1.40s/it]Validating:  71%|   | 71/100 [02:25<00:40,  1.40s/it]Validating:  72%|  | 72/100 [02:27<00:39,  1.40s/it]Validating:  73%|  | 73/100 [02:28<00:37,  1.40s/it]Validating:  74%|  | 74/100 [02:29<00:36,  1.40s/it]Validating:  75%|  | 75/100 [02:31<00:35,  1.40s/it]Validating:  76%|  | 76/100 [02:32<00:33,  1.40s/it]Validating:  77%|  | 77/100 [02:34<00:32,  1.39s/it]Validating:  78%|  | 78/100 [02:35<00:30,  1.39s/it]Validating:  79%|  | 79/100 [02:36<00:29,  1.40s/it]Validating:  80%|  | 80/100 [02:38<00:27,  1.40s/it]Validating:  81%|  | 81/100 [02:39<00:26,  1.39s/it]Validating:  82%| | 82/100 [02:41<00:25,  1.40s/it]Validating:  83%| | 83/100 [02:42<00:23,  1.40s/it]Validating:  84%| | 84/100 [02:43<00:22,  1.40s/it]Validating:  85%| | 85/100 [02:45<00:21,  1.40s/it]Validating:  86%| | 86/100 [02:46<00:19,  1.40s/it]Validating:  87%| | 87/100 [02:48<00:18,  1.39s/it]Validating:  88%| | 88/100 [02:49<00:16,  1.40s/it]Validating:  89%| | 89/100 [02:50<00:15,  1.38s/it]Validating:  90%| | 90/100 [02:52<00:13,  1.36s/it]Validating:  91%| | 91/100 [02:53<00:12,  1.35s/it]Validating:  92%|| 92/100 [02:54<00:10,  1.35s/it]Validating:  93%|| 93/100 [02:56<00:09,  1.35s/it]Validating:  94%|| 94/100 [02:57<00:08,  1.35s/it]Validating:  95%|| 95/100 [02:58<00:06,  1.35s/it]Validating:  96%|| 96/100 [03:00<00:05,  1.35s/it]Validating:  97%|| 97/100 [03:01<00:04,  1.35s/it]Validating:  98%|| 98/100 [03:02<00:02,  1.35s/it]Validating:  99%|| 99/100 [03:04<00:01,  1.35s/it]Validating: 100%|| 100/100 [03:05<00:00,  1.36s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:08<00:00,  1.88s/it]
SRCC0.9364377361555327PLCC0.9378409865724974KRCC0.7936312158108878RMSE0.1727440342507699
{'val_n/best_SRCC-n': 0.9364377361555327, 'val_n/best_PLCC-n': 0.9378409865724974, 'val_n/best_KRCC-n': 0.7936312158108878, 'val_n/best_RMSE-n': 0.1727440342507699}
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:46<1:16:56, 46.63s/it]Validating:   2%|         | 2/100 [00:48<32:53, 20.14s/it]  Validating:   3%|         | 3/100 [00:49<18:46, 11.62s/it]Validating:   4%|         | 4/100 [00:51<12:10,  7.61s/it]Validating:   5%|         | 5/100 [00:52<08:33,  5.41s/it]Validating:   6%|         | 6/100 [00:54<06:23,  4.08s/it]Validating:   7%|         | 7/100 [00:55<04:59,  3.23s/it]Validating:   8%|         | 8/100 [00:57<04:06,  2.68s/it]Validating:   9%|         | 9/100 [00:58<03:30,  2.31s/it]Validating:  10%|         | 10/100 [01:00<03:06,  2.07s/it]Validating:  11%|         | 11/100 [01:01<02:48,  1.89s/it]Validating:  12%|        | 12/100 [01:03<02:36,  1.78s/it]Validating:  13%|        | 13/100 [01:04<02:27,  1.69s/it]Validating:  14%|        | 14/100 [01:06<02:20,  1.64s/it]Validating:  15%|        | 15/100 [01:07<02:15,  1.59s/it]Validating:  16%|        | 16/100 [01:09<02:11,  1.57s/it]Validating:  17%|        | 17/100 [01:10<02:09,  1.56s/it]Validating:  18%|        | 18/100 [01:12<02:07,  1.55s/it]Validating:  19%|        | 19/100 [01:13<02:06,  1.56s/it]Validating:  20%|        | 20/100 [01:15<02:04,  1.55s/it]Validating:  21%|        | 21/100 [01:16<02:02,  1.55s/it]Validating:  22%|       | 22/100 [01:18<02:01,  1.55s/it]Validating:  23%|       | 23/100 [01:20<01:59,  1.56s/it]Validating:  24%|       | 24/100 [01:21<01:57,  1.55s/it]Validating:  25%|       | 25/100 [01:23<01:55,  1.53s/it]Validating:  26%|       | 26/100 [01:24<01:52,  1.52s/it]Validating:  27%|       | 27/100 [01:26<01:50,  1.51s/it]Validating:  28%|       | 28/100 [01:27<01:48,  1.50s/it]Validating:  29%|       | 29/100 [01:29<01:46,  1.50s/it]Validating:  30%|       | 30/100 [01:30<01:45,  1.51s/it]Validating:  31%|       | 31/100 [01:32<01:44,  1.52s/it]Validating:  32%|      | 32/100 [01:33<01:41,  1.49s/it]Validating:  33%|      | 33/100 [01:34<01:39,  1.48s/it]Validating:  34%|      | 34/100 [01:36<01:38,  1.49s/it]Validating:  35%|      | 35/100 [01:37<01:37,  1.49s/it]Validating:  36%|      | 36/100 [01:39<01:36,  1.51s/it]Validating:  37%|      | 37/100 [01:41<01:36,  1.53s/it]Validating:  38%|      | 38/100 [01:42<01:34,  1.52s/it]Validating:  39%|      | 39/100 [01:44<01:32,  1.52s/it]Validating:  40%|      | 40/100 [01:45<01:31,  1.52s/it]Validating:  41%|      | 41/100 [01:47<01:31,  1.54s/it]Validating:  42%|     | 42/100 [01:48<01:29,  1.55s/it]Validating:  43%|     | 43/100 [01:50<01:28,  1.56s/it]Validating:  44%|     | 44/100 [01:51<01:26,  1.55s/it]Validating:  45%|     | 45/100 [01:53<01:23,  1.52s/it]Validating:  46%|     | 46/100 [01:54<01:20,  1.49s/it]Validating:  47%|     | 47/100 [01:56<01:18,  1.49s/it]Validating:  48%|     | 48/100 [01:57<01:17,  1.48s/it]Validating:  49%|     | 49/100 [01:59<01:15,  1.47s/it]Validating:  50%|     | 50/100 [02:00<01:13,  1.46s/it]Validating:  51%|     | 51/100 [02:02<01:11,  1.47s/it]Validating:  52%|    | 52/100 [02:03<01:12,  1.50s/it]Validating:  53%|    | 53/100 [02:05<01:12,  1.54s/it]Validating:  54%|    | 54/100 [02:06<01:11,  1.55s/it]Validating:  55%|    | 55/100 [02:08<01:10,  1.58s/it]Validating:  56%|    | 56/100 [02:10<01:09,  1.57s/it]Validating:  57%|    | 57/100 [02:11<01:06,  1.55s/it]Validating:  58%|    | 58/100 [02:13<01:04,  1.53s/it]Validating:  59%|    | 59/100 [02:14<01:02,  1.53s/it]Validating:  60%|    | 60/100 [02:16<01:00,  1.51s/it]Validating:  61%|    | 61/100 [02:17<00:58,  1.49s/it]Validating:  62%|   | 62/100 [02:19<00:56,  1.48s/it]Validating:  63%|   | 63/100 [02:20<00:54,  1.48s/it]Validating:  64%|   | 64/100 [02:21<00:52,  1.46s/it]Validating:  65%|   | 65/100 [02:23<00:51,  1.46s/it]Validating:  66%|   | 66/100 [02:24<00:51,  1.50s/it]Validating:  67%|   | 67/100 [02:26<00:49,  1.50s/it]Validating:  68%|   | 68/100 [02:27<00:48,  1.51s/it]Validating:  69%|   | 69/100 [02:29<00:47,  1.53s/it]Validating:  70%|   | 70/100 [02:31<00:45,  1.53s/it]Validating:  71%|   | 71/100 [02:32<00:44,  1.52s/it]Validating:  72%|  | 72/100 [02:34<00:42,  1.51s/it]Validating:  73%|  | 73/100 [02:35<00:40,  1.50s/it]Validating:  74%|  | 74/100 [02:37<00:38,  1.49s/it]Validating:  75%|  | 75/100 [02:38<00:37,  1.48s/it]Validating:  76%|  | 76/100 [02:40<00:35,  1.49s/it]Validating:  77%|  | 77/100 [02:41<00:34,  1.50s/it]Validating:  78%|  | 78/100 [02:43<00:33,  1.50s/it]Validating:  79%|  | 79/100 [02:44<00:31,  1.52s/it]Validating:  80%|  | 80/100 [02:46<00:30,  1.51s/it]Validating:  81%|  | 81/100 [02:47<00:28,  1.51s/it]Validating:  82%| | 82/100 [02:49<00:27,  1.51s/it]Validating:  83%| | 83/100 [02:50<00:25,  1.49s/it]Validating:  84%| | 84/100 [02:52<00:23,  1.49s/it]Validating:  85%| | 85/100 [02:53<00:22,  1.48s/it]Validating:  86%| | 86/100 [02:54<00:20,  1.47s/it]Validating:  87%| | 87/100 [02:56<00:19,  1.46s/it]Validating:  88%| | 88/100 [02:57<00:17,  1.47s/it]Validating:  89%| | 89/100 [02:59<00:15,  1.45s/it]Validating:  90%| | 90/100 [03:00<00:14,  1.44s/it]Validating:  91%| | 91/100 [03:02<00:12,  1.42s/it]Validating:  92%|| 92/100 [03:03<00:11,  1.42s/it]Validating:  93%|| 93/100 [03:04<00:09,  1.42s/it]Validating:  94%|| 94/100 [03:06<00:08,  1.41s/it]Validating:  95%|| 95/100 [03:07<00:07,  1.41s/it]Validating:  96%|| 96/100 [03:09<00:05,  1.41s/it]Validating:  97%|| 97/100 [03:10<00:04,  1.41s/it]Validating:  98%|| 98/100 [03:11<00:02,  1.41s/it]Validating:  99%|| 99/100 [03:13<00:01,  1.41s/it]Validating: 100%|| 100/100 [03:14<00:00,  1.41s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:17<00:00,  1.98s/it]
SRCC0.7934952544679539PLCC0.802606720899056KRCC0.6131956866324308RMSE0.3078344320473642
{'val_s/best_SRCC-s': 0.7934952544679539, 'val_s/best_PLCC-s': 0.802606720899056, 'val_s/best_KRCC-s': 0.6131956866324308, 'val_s/best_RMSE-s': 0.3078344320473642}
Epoch 0 completed. Average Loss: 0.04598478471278213

                the best validation accuracy of the model-s is as follows:
                SROCC: 0.9364
                PLCC:  0.9378
                KROCC: 0.7936
                RMSE:  0.1727.

                the best validation accuracy of the model-n is as follows:
                SROCC: 0.7935
                PLCC:  0.8026
                KROCC: 0.6132
                RMSE:  0.3078.
End-to-end Epoch 1:
Training in epoch 1:   0%|          | 0/25 [00:00<?, ?it/s]Training in epoch 1:   4%|         | 1/25 [01:08<27:16, 68.18s/it]Training in epoch 1:   8%|         | 2/25 [01:27<15:11, 39.61s/it]Training in epoch 1:  12%|        | 3/25 [01:46<10:58, 29.91s/it]Training in epoch 1:  16%|        | 4/25 [02:04<08:50, 25.28s/it]Training in epoch 1:  20%|        | 5/25 [02:23<07:39, 22.96s/it]Training in epoch 1:  24%|       | 6/25 [02:41<06:46, 21.39s/it]Training in epoch 1:  28%|       | 7/25 [03:00<06:08, 20.47s/it]Training in epoch 1:  32%|      | 8/25 [03:19<05:40, 20.02s/it]Training in epoch 1:  36%|      | 9/25 [03:37<05:11, 19.45s/it]Training in epoch 1:  40%|      | 10/25 [03:55<04:46, 19.11s/it]Training in epoch 1:  44%|     | 11/25 [04:14<04:24, 18.88s/it]Training in epoch 1:  48%|     | 12/25 [04:32<04:04, 18.81s/it]Training in epoch 1:  52%|    | 13/25 [04:51<03:44, 18.69s/it]Training in epoch 1:  56%|    | 14/25 [05:09<03:23, 18.47s/it]Training in epoch 1:  60%|    | 15/25 [05:26<03:02, 18.29s/it]Training in epoch 1:  64%|   | 16/25 [05:44<02:43, 18.13s/it]Training in epoch 1:  68%|   | 17/25 [06:02<02:24, 18.08s/it]Training in epoch 1:  72%|  | 18/25 [06:21<02:07, 18.16s/it]Training in epoch 1:  76%|  | 19/25 [06:38<01:47, 17.92s/it]Training in epoch 1:  80%|  | 20/25 [06:56<01:29, 17.89s/it]Training in epoch 1:  84%| | 21/25 [07:13<01:11, 17.81s/it]Training in epoch 1:  88%| | 22/25 [07:31<00:53, 17.91s/it]Training in epoch 1:  92%|| 23/25 [07:49<00:35, 17.94s/it]Training in epoch 1:  96%|| 24/25 [08:07<00:17, 17.82s/it]Training in epoch 1: 100%|| 25/25 [08:25<00:00, 17.81s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Training in epoch 1: 100%|| 25/25 [08:29<00:00, 20.38s/it]
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:45<1:14:19, 45.04s/it]Validating:   2%|         | 2/100 [00:46<31:42, 19.41s/it]  Validating:   3%|         | 3/100 [00:48<18:09, 11.23s/it]Validating:   4%|         | 4/100 [00:49<11:45,  7.34s/it]Validating:   5%|         | 5/100 [00:50<08:14,  5.20s/it]Validating:   6%|         | 6/100 [00:52<06:07,  3.91s/it]Validating:   7%|         | 7/100 [00:53<04:46,  3.08s/it]Validating:   8%|         | 8/100 [00:54<03:53,  2.54s/it]Validating:   9%|         | 9/100 [00:56<03:17,  2.18s/it]Validating:  10%|         | 10/100 [00:57<02:55,  1.94s/it]Validating:  11%|         | 11/100 [00:59<02:38,  1.78s/it]Validating:  12%|        | 12/100 [01:00<02:26,  1.67s/it]Validating:  13%|        | 13/100 [01:02<02:18,  1.60s/it]Validating:  14%|        | 14/100 [01:03<02:12,  1.54s/it]Validating:  15%|        | 15/100 [01:04<02:07,  1.50s/it]Validating:  16%|        | 16/100 [01:06<02:04,  1.48s/it]Validating:  17%|        | 17/100 [01:07<02:01,  1.47s/it]Validating:  18%|        | 18/100 [01:09<01:59,  1.45s/it]Validating:  19%|        | 19/100 [01:10<01:57,  1.46s/it]Validating:  20%|        | 20/100 [01:11<01:55,  1.44s/it]Validating:  21%|        | 21/100 [01:13<01:54,  1.45s/it]Validating:  22%|       | 22/100 [01:14<01:52,  1.45s/it]Validating:  23%|       | 23/100 [01:16<01:51,  1.44s/it]Validating:  24%|       | 24/100 [01:17<01:49,  1.44s/it]Validating:  25%|       | 25/100 [01:19<01:47,  1.43s/it]Validating:  26%|       | 26/100 [01:20<01:45,  1.42s/it]Validating:  27%|       | 27/100 [01:21<01:43,  1.42s/it]Validating:  28%|       | 28/100 [01:23<01:41,  1.41s/it]Validating:  29%|       | 29/100 [01:24<01:40,  1.41s/it]Validating:  30%|       | 30/100 [01:26<01:38,  1.41s/it]Validating:  31%|       | 31/100 [01:27<01:37,  1.41s/it]Validating:  32%|      | 32/100 [01:28<01:33,  1.38s/it]Validating:  33%|      | 33/100 [01:30<01:32,  1.39s/it]Validating:  34%|      | 34/100 [01:31<01:31,  1.39s/it]Validating:  35%|      | 35/100 [01:33<01:31,  1.40s/it]Validating:  36%|      | 36/100 [01:34<01:29,  1.41s/it]Validating:  37%|      | 37/100 [01:35<01:28,  1.41s/it]Validating:  38%|      | 38/100 [01:37<01:27,  1.41s/it]Validating:  39%|      | 39/100 [01:38<01:26,  1.42s/it]Validating:  40%|      | 40/100 [01:40<01:26,  1.44s/it]Validating:  41%|      | 41/100 [01:41<01:24,  1.43s/it]Validating:  42%|     | 42/100 [01:43<01:23,  1.45s/it]Validating:  43%|     | 43/100 [01:44<01:22,  1.45s/it]Validating:  44%|     | 44/100 [01:46<01:21,  1.45s/it]Validating:  45%|     | 45/100 [01:47<01:19,  1.44s/it]Validating:  46%|     | 46/100 [01:48<01:16,  1.42s/it]Validating:  47%|     | 47/100 [01:50<01:14,  1.41s/it]Validating:  48%|     | 48/100 [01:51<01:13,  1.41s/it]Validating:  49%|     | 49/100 [01:53<01:12,  1.42s/it]Validating:  50%|     | 50/100 [01:54<01:10,  1.42s/it]Validating:  51%|     | 51/100 [01:55<01:09,  1.43s/it]Validating:  52%|    | 52/100 [01:57<01:10,  1.47s/it]Validating:  53%|    | 53/100 [01:59<01:09,  1.49s/it]Validating:  54%|    | 54/100 [02:00<01:08,  1.49s/it]Validating:  55%|    | 55/100 [02:02<01:07,  1.51s/it]Validating:  56%|    | 56/100 [02:03<01:05,  1.48s/it]Validating:  57%|    | 57/100 [02:05<01:03,  1.48s/it]Validating:  58%|    | 58/100 [02:06<01:02,  1.48s/it]Validating:  59%|    | 59/100 [02:07<01:00,  1.47s/it]Validating:  60%|    | 60/100 [02:09<00:57,  1.45s/it]Validating:  61%|    | 61/100 [02:10<00:55,  1.42s/it]Validating:  62%|   | 62/100 [02:12<00:53,  1.41s/it]Validating:  63%|   | 63/100 [02:13<00:51,  1.40s/it]Validating:  64%|   | 64/100 [02:14<00:50,  1.39s/it]Validating:  65%|   | 65/100 [02:16<00:48,  1.38s/it]Validating:  66%|   | 66/100 [02:17<00:47,  1.40s/it]Validating:  67%|   | 67/100 [02:19<00:46,  1.41s/it]Validating:  68%|   | 68/100 [02:20<00:45,  1.41s/it]Validating:  69%|   | 69/100 [02:21<00:43,  1.41s/it]Validating:  70%|   | 70/100 [02:23<00:42,  1.41s/it]Validating:  71%|   | 71/100 [02:24<00:40,  1.41s/it]Validating:  72%|  | 72/100 [02:26<00:39,  1.42s/it]Validating:  73%|  | 73/100 [02:27<00:38,  1.42s/it]Validating:  74%|  | 74/100 [02:28<00:36,  1.42s/it]Validating:  75%|  | 75/100 [02:30<00:36,  1.44s/it]Validating:  76%|  | 76/100 [02:31<00:34,  1.46s/it]Validating:  77%|  | 77/100 [02:33<00:33,  1.46s/it]Validating:  78%|  | 78/100 [02:34<00:32,  1.46s/it]Validating:  79%|  | 79/100 [02:36<00:30,  1.47s/it]Validating:  80%|  | 80/100 [02:37<00:29,  1.49s/it]Validating:  81%|  | 81/100 [02:39<00:28,  1.48s/it]Validating:  82%| | 82/100 [02:40<00:26,  1.47s/it]Validating:  83%| | 83/100 [02:42<00:24,  1.46s/it]Validating:  84%| | 84/100 [02:43<00:23,  1.46s/it]Validating:  85%| | 85/100 [02:45<00:22,  1.47s/it]Validating:  86%| | 86/100 [02:46<00:21,  1.51s/it]Validating:  87%| | 87/100 [02:48<00:20,  1.54s/it]Validating:  88%| | 88/100 [02:49<00:18,  1.53s/it]Validating:  89%| | 89/100 [02:51<00:16,  1.48s/it]Validating:  90%| | 90/100 [02:52<00:14,  1.47s/it]Validating:  91%| | 91/100 [02:54<00:13,  1.49s/it]Validating:  92%|| 92/100 [02:55<00:11,  1.47s/it]Validating:  93%|| 93/100 [02:57<00:10,  1.46s/it]Validating:  94%|| 94/100 [02:58<00:08,  1.44s/it]Validating:  95%|| 95/100 [02:59<00:07,  1.43s/it]Validating:  96%|| 96/100 [03:01<00:05,  1.42s/it]Validating:  97%|| 97/100 [03:02<00:04,  1.44s/it]Validating:  98%|| 98/100 [03:04<00:02,  1.44s/it]Validating:  99%|| 99/100 [03:05<00:01,  1.42s/it]Validating: 100%|| 100/100 [03:07<00:00,  1.41s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:11<00:00,  1.92s/it]
SRCC0.9337724219497001PLCC0.9291353578516244KRCC0.791594697422869RMSE0.18444455483109054
{'val_n/best_SRCC-n': 0.9364377361555327, 'val_n/best_PLCC-n': 0.9378409865724974, 'val_n/best_KRCC-n': 0.7936312158108878, 'val_n/best_RMSE-n': 0.1727440342507699}
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:50<1:23:50, 50.81s/it]Validating:   2%|         | 2/100 [00:52<35:42, 21.87s/it]  Validating:   3%|         | 3/100 [00:53<20:18, 12.56s/it]Validating:   4%|         | 4/100 [00:55<13:05,  8.19s/it]Validating:   5%|         | 5/100 [00:56<09:09,  5.79s/it]Validating:   6%|         | 6/100 [00:58<06:46,  4.32s/it]Validating:   7%|         | 7/100 [00:59<05:18,  3.42s/it]Validating:   8%|         | 8/100 [01:01<04:18,  2.81s/it]Validating:   9%|         | 9/100 [01:03<03:40,  2.42s/it]Validating:  10%|         | 10/100 [01:04<03:14,  2.16s/it]Validating:  11%|         | 11/100 [01:06<02:56,  1.98s/it]Validating:  12%|        | 12/100 [01:07<02:42,  1.84s/it]Validating:  13%|        | 13/100 [01:09<02:33,  1.77s/it]Validating:  14%|        | 14/100 [01:10<02:25,  1.69s/it]Validating:  15%|        | 15/100 [01:12<02:19,  1.65s/it]Validating:  16%|        | 16/100 [01:13<02:13,  1.59s/it]Validating:  17%|        | 17/100 [01:15<02:10,  1.58s/it]Validating:  18%|        | 18/100 [01:17<02:14,  1.63s/it]Validating:  19%|        | 19/100 [01:18<02:11,  1.63s/it]Validating:  20%|        | 20/100 [01:20<02:10,  1.63s/it]Validating:  21%|        | 21/100 [01:21<02:08,  1.62s/it]Validating:  22%|       | 22/100 [01:23<02:05,  1.61s/it]Validating:  23%|       | 23/100 [01:25<02:03,  1.60s/it]Validating:  24%|       | 24/100 [01:26<02:00,  1.59s/it]Validating:  25%|       | 25/100 [01:28<01:58,  1.58s/it]Validating:  26%|       | 26/100 [01:29<01:56,  1.57s/it]Validating:  27%|       | 27/100 [01:31<01:54,  1.57s/it]Validating:  28%|       | 28/100 [01:32<01:53,  1.58s/it]Validating:  29%|       | 29/100 [01:34<01:53,  1.59s/it]Validating:  30%|       | 30/100 [01:36<01:50,  1.57s/it]Validating:  31%|       | 31/100 [01:37<01:50,  1.60s/it]Validating:  32%|      | 32/100 [01:39<01:48,  1.60s/it]Validating:  33%|      | 33/100 [01:41<01:49,  1.63s/it]Validating:  34%|      | 34/100 [01:42<01:47,  1.63s/it]Validating:  35%|      | 35/100 [01:44<01:45,  1.62s/it]Validating:  36%|      | 36/100 [01:45<01:42,  1.59s/it]Validating:  37%|      | 37/100 [01:47<01:38,  1.57s/it]Validating:  38%|      | 38/100 [01:48<01:37,  1.57s/it]Validating:  39%|      | 39/100 [01:50<01:36,  1.58s/it]Validating:  40%|      | 40/100 [01:52<01:36,  1.60s/it]Validating:  41%|      | 41/100 [01:53<01:34,  1.61s/it]Validating:  42%|     | 42/100 [01:55<01:33,  1.60s/it]Validating:  43%|     | 43/100 [01:56<01:30,  1.60s/it]Validating:  44%|     | 44/100 [01:58<01:29,  1.59s/it]Validating:  45%|     | 45/100 [02:00<01:25,  1.56s/it]Validating:  46%|     | 46/100 [02:01<01:22,  1.53s/it]Validating:  47%|     | 47/100 [02:03<01:20,  1.52s/it]Validating:  48%|     | 48/100 [02:04<01:18,  1.51s/it]Validating:  49%|     | 49/100 [02:05<01:16,  1.50s/it]Validating:  50%|     | 50/100 [02:07<01:15,  1.50s/it]Validating:  51%|     | 51/100 [02:09<01:14,  1.52s/it]Validating:  52%|    | 52/100 [02:10<01:14,  1.55s/it]Validating:  53%|    | 53/100 [02:12<01:14,  1.59s/it]Validating:  54%|    | 54/100 [02:13<01:12,  1.59s/it]Validating:  55%|    | 55/100 [02:15<01:10,  1.57s/it]Validating:  56%|    | 56/100 [02:17<01:09,  1.57s/it]Validating:  57%|    | 57/100 [02:18<01:07,  1.56s/it]Validating:  58%|    | 58/100 [02:20<01:05,  1.56s/it]Validating:  59%|    | 59/100 [02:21<01:03,  1.54s/it]Validating:  60%|    | 60/100 [02:23<01:01,  1.53s/it]Validating:  61%|    | 61/100 [02:24<00:59,  1.53s/it]Validating:  62%|   | 62/100 [02:26<00:57,  1.52s/it]Validating:  63%|   | 63/100 [02:27<00:55,  1.51s/it]Validating:  64%|   | 64/100 [02:29<00:54,  1.50s/it]Validating:  65%|   | 65/100 [02:30<00:51,  1.49s/it]Validating:  66%|   | 66/100 [02:32<00:50,  1.50s/it]Validating:  67%|   | 67/100 [02:33<00:49,  1.49s/it]Validating:  68%|   | 68/100 [02:35<00:47,  1.49s/it]Validating:  69%|   | 69/100 [02:36<00:46,  1.51s/it]Validating:  70%|   | 70/100 [02:38<00:45,  1.50s/it]Validating:  71%|   | 71/100 [02:39<00:43,  1.50s/it]Validating:  72%|  | 72/100 [02:41<00:42,  1.51s/it]Validating:  73%|  | 73/100 [02:42<00:40,  1.51s/it]Validating:  74%|  | 74/100 [02:44<00:39,  1.52s/it]Validating:  75%|  | 75/100 [02:45<00:37,  1.50s/it]Validating:  76%|  | 76/100 [02:47<00:35,  1.50s/it]Validating:  77%|  | 77/100 [02:48<00:34,  1.50s/it]Validating:  78%|  | 78/100 [02:50<00:33,  1.51s/it]Validating:  79%|  | 79/100 [02:51<00:31,  1.51s/it]Validating:  80%|  | 80/100 [02:53<00:29,  1.50s/it]Validating:  81%|  | 81/100 [02:54<00:28,  1.49s/it]Validating:  82%| | 82/100 [02:56<00:26,  1.50s/it]Validating:  83%| | 83/100 [02:57<00:25,  1.53s/it]Validating:  84%| | 84/100 [02:59<00:24,  1.54s/it]Validating:  85%| | 85/100 [03:00<00:23,  1.54s/it]Validating:  86%| | 86/100 [03:02<00:21,  1.55s/it]Validating:  87%| | 87/100 [03:03<00:20,  1.54s/it]Validating:  88%| | 88/100 [03:05<00:18,  1.51s/it]Validating:  89%| | 89/100 [03:06<00:16,  1.50s/it]Validating:  90%| | 90/100 [03:08<00:14,  1.48s/it]Validating:  91%| | 91/100 [03:09<00:13,  1.46s/it]Validating:  92%|| 92/100 [03:11<00:11,  1.44s/it]Validating:  93%|| 93/100 [03:12<00:10,  1.43s/it]Validating:  94%|| 94/100 [03:13<00:08,  1.43s/it]Validating:  95%|| 95/100 [03:15<00:07,  1.42s/it]Validating:  96%|| 96/100 [03:16<00:05,  1.42s/it]Validating:  97%|| 97/100 [03:18<00:04,  1.42s/it]Validating:  98%|| 98/100 [03:19<00:02,  1.45s/it]Validating:  99%|| 99/100 [03:21<00:01,  1.45s/it]Validating: 100%|| 100/100 [03:22<00:00,  1.45s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:28<00:00,  2.08s/it]
SRCC0.7775213781127277PLCC0.7981883512376049KRCC0.59568162849547RMSE0.31126057687509345
{'val_s/best_SRCC-s': 0.7934952544679539, 'val_s/best_PLCC-s': 0.802606720899056, 'val_s/best_KRCC-s': 0.6131956866324308, 'val_s/best_RMSE-s': 0.3078344320473642}
Epoch 1 completed. Average Loss: 0.06419672889285721

                the best validation accuracy of the model-s is as follows:
                SROCC: 0.9364
                PLCC:  0.9378
                KROCC: 0.7936
                RMSE:  0.1727.

                the best validation accuracy of the model-n is as follows:
                SROCC: 0.7935
                PLCC:  0.8026
                KROCC: 0.6132
                RMSE:  0.3078.
End-to-end Epoch 2:
Training in epoch 2:   0%|          | 0/25 [00:00<?, ?it/s]Training in epoch 2:   4%|         | 1/25 [01:16<30:24, 76.02s/it]Training in epoch 2:   8%|         | 2/25 [01:34<16:14, 42.35s/it]Training in epoch 2:  12%|        | 3/25 [01:52<11:26, 31.22s/it]Training in epoch 2:  16%|        | 4/25 [02:10<09:07, 26.06s/it]Training in epoch 2:  20%|        | 5/25 [02:28<07:43, 23.17s/it]Training in epoch 2:  24%|       | 6/25 [02:46<06:45, 21.32s/it]Training in epoch 2:  28%|       | 7/25 [03:05<06:06, 20.34s/it]Training in epoch 2:  32%|      | 8/25 [03:22<05:32, 19.57s/it]Training in epoch 2:  36%|      | 9/25 [03:41<05:05, 19.10s/it]Training in epoch 2:  40%|      | 10/25 [03:58<04:41, 18.75s/it]Training in epoch 2:  44%|     | 11/25 [04:18<04:24, 18.87s/it]Training in epoch 2:  48%|     | 12/25 [04:36<04:05, 18.86s/it]Training in epoch 2:  52%|    | 13/25 [04:55<03:44, 18.68s/it]Training in epoch 2:  56%|    | 14/25 [05:13<03:24, 18.55s/it]Training in epoch 2:  60%|    | 15/25 [05:31<03:05, 18.53s/it]Training in epoch 2:  64%|   | 16/25 [05:50<02:46, 18.52s/it]Training in epoch 2:  68%|   | 17/25 [06:08<02:26, 18.31s/it]Training in epoch 2:  72%|  | 18/25 [06:26<02:08, 18.30s/it]Training in epoch 2:  76%|  | 19/25 [06:44<01:48, 18.12s/it]Training in epoch 2:  80%|  | 20/25 [07:02<01:30, 18.04s/it]Training in epoch 2:  84%| | 21/25 [07:19<01:11, 17.86s/it]Training in epoch 2:  88%| | 22/25 [07:37<00:53, 17.79s/it]Training in epoch 2:  92%|| 23/25 [07:55<00:35, 17.92s/it]Training in epoch 2:  96%|| 24/25 [08:13<00:17, 17.94s/it]Training in epoch 2: 100%|| 25/25 [08:31<00:00, 17.95s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Training in epoch 2: 100%|| 25/25 [08:35<00:00, 20.62s/it]
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:46<1:16:32, 46.39s/it]Validating:   2%|         | 2/100 [00:47<32:40, 20.01s/it]  Validating:   3%|         | 3/100 [00:49<18:38, 11.53s/it]Validating:   4%|         | 4/100 [00:50<12:06,  7.56s/it]Validating:   5%|         | 5/100 [00:52<08:28,  5.35s/it]Validating:   6%|         | 6/100 [00:53<06:18,  4.03s/it]Validating:   7%|         | 7/100 [00:55<04:56,  3.19s/it]Validating:   8%|         | 8/100 [00:56<04:01,  2.63s/it]Validating:   9%|         | 9/100 [00:58<03:25,  2.25s/it]Validating:  10%|         | 10/100 [00:59<03:01,  2.01s/it]Validating:  11%|         | 11/100 [01:01<02:44,  1.85s/it]Validating:  12%|        | 12/100 [01:02<02:31,  1.73s/it]Validating:  13%|        | 13/100 [01:03<02:24,  1.66s/it]Validating:  14%|        | 14/100 [01:05<02:19,  1.62s/it]Validating:  15%|        | 15/100 [01:07<02:15,  1.59s/it]Validating:  16%|        | 16/100 [01:08<02:10,  1.55s/it]Validating:  17%|        | 17/100 [01:09<02:06,  1.53s/it]Validating:  18%|        | 18/100 [01:11<02:03,  1.50s/it]Validating:  19%|        | 19/100 [01:12<02:02,  1.51s/it]Validating:  20%|        | 20/100 [01:14<02:00,  1.51s/it]Validating:  21%|        | 21/100 [01:16<02:01,  1.53s/it]Validating:  22%|       | 22/100 [01:17<02:00,  1.55s/it]Validating:  23%|       | 23/100 [01:19<02:00,  1.56s/it]Validating:  24%|       | 24/100 [01:20<01:59,  1.57s/it]Validating:  25%|       | 25/100 [01:22<01:56,  1.55s/it]Validating:  26%|       | 26/100 [01:23<01:52,  1.51s/it]Validating:  27%|       | 27/100 [01:25<01:49,  1.50s/it]Validating:  28%|       | 28/100 [01:26<01:46,  1.48s/it]Validating:  29%|       | 29/100 [01:28<01:44,  1.47s/it]Validating:  30%|       | 30/100 [01:29<01:42,  1.47s/it]Validating:  31%|       | 31/100 [01:31<01:42,  1.49s/it]Validating:  32%|      | 32/100 [01:32<01:41,  1.49s/it]Validating:  33%|      | 33/100 [01:34<01:41,  1.51s/it]Validating:  34%|      | 34/100 [01:35<01:40,  1.52s/it]Validating:  35%|      | 35/100 [01:37<01:38,  1.51s/it]Validating:  36%|      | 36/100 [01:38<01:36,  1.51s/it]Validating:  37%|      | 37/100 [01:40<01:34,  1.50s/it]Validating:  38%|      | 38/100 [01:41<01:32,  1.49s/it]Validating:  39%|      | 39/100 [01:43<01:32,  1.51s/it]Validating:  40%|      | 40/100 [01:44<01:34,  1.58s/it]Validating:  41%|      | 41/100 [01:46<01:36,  1.63s/it]Validating:  42%|     | 42/100 [01:48<01:34,  1.63s/it]Validating:  43%|     | 43/100 [01:49<01:31,  1.60s/it]Validating:  44%|     | 44/100 [01:51<01:30,  1.62s/it]Validating:  45%|     | 45/100 [01:52<01:26,  1.57s/it]Validating:  46%|     | 46/100 [01:54<01:24,  1.56s/it]Validating:  47%|     | 47/100 [01:55<01:20,  1.52s/it]Validating:  48%|     | 48/100 [01:57<01:19,  1.52s/it]Validating:  49%|     | 49/100 [01:58<01:17,  1.52s/it]Validating:  50%|     | 50/100 [02:00<01:15,  1.50s/it]Validating:  51%|     | 51/100 [02:02<01:16,  1.57s/it]Validating:  52%|    | 52/100 [02:03<01:16,  1.58s/it]Validating:  53%|    | 53/100 [02:05<01:14,  1.59s/it]Validating:  54%|    | 54/100 [02:07<01:14,  1.63s/it]Validating:  55%|    | 55/100 [02:08<01:12,  1.60s/it]Validating:  56%|    | 56/100 [02:10<01:09,  1.59s/it]Validating:  57%|    | 57/100 [02:11<01:11,  1.65s/it]Validating:  58%|    | 58/100 [02:13<01:08,  1.63s/it]Validating:  59%|    | 59/100 [02:15<01:04,  1.58s/it]Validating:  60%|    | 60/100 [02:16<01:01,  1.54s/it]Validating:  61%|    | 61/100 [02:17<00:59,  1.51s/it]Validating:  62%|   | 62/100 [02:19<00:56,  1.49s/it]Validating:  63%|   | 63/100 [02:20<00:54,  1.48s/it]Validating:  64%|   | 64/100 [02:22<00:53,  1.48s/it]Validating:  65%|   | 65/100 [02:23<00:51,  1.47s/it]Validating:  66%|   | 66/100 [02:25<00:50,  1.48s/it]Validating:  67%|   | 67/100 [02:26<00:49,  1.50s/it]Validating:  68%|   | 68/100 [02:28<00:47,  1.50s/it]Validating:  69%|   | 69/100 [02:29<00:46,  1.50s/it]Validating:  70%|   | 70/100 [02:31<00:45,  1.53s/it]Validating:  71%|   | 71/100 [02:32<00:43,  1.51s/it]Validating:  72%|  | 72/100 [02:34<00:41,  1.49s/it]Validating:  73%|  | 73/100 [02:35<00:39,  1.46s/it]Validating:  74%|  | 74/100 [02:37<00:38,  1.47s/it]Validating:  75%|  | 75/100 [02:38<00:36,  1.46s/it]Validating:  76%|  | 76/100 [02:40<00:35,  1.48s/it]Validating:  77%|  | 77/100 [02:41<00:33,  1.47s/it]Validating:  78%|  | 78/100 [02:42<00:31,  1.45s/it]Validating:  79%|  | 79/100 [02:44<00:30,  1.44s/it]Validating:  80%|  | 80/100 [02:45<00:28,  1.43s/it]Validating:  81%|  | 81/100 [02:47<00:27,  1.45s/it]Validating:  82%| | 82/100 [02:48<00:26,  1.46s/it]Validating:  83%| | 83/100 [02:50<00:24,  1.44s/it]Validating:  84%| | 84/100 [02:51<00:23,  1.44s/it]Validating:  85%| | 85/100 [02:53<00:21,  1.43s/it]Validating:  86%| | 86/100 [02:54<00:20,  1.43s/it]Validating:  87%| | 87/100 [02:55<00:18,  1.44s/it]Validating:  88%| | 88/100 [02:57<00:17,  1.44s/it]Validating:  89%| | 89/100 [02:58<00:15,  1.42s/it]Validating:  90%| | 90/100 [03:00<00:13,  1.40s/it]Validating:  91%| | 91/100 [03:01<00:12,  1.38s/it]Validating:  92%|| 92/100 [03:02<00:10,  1.37s/it]Validating:  93%|| 93/100 [03:04<00:09,  1.37s/it]Validating:  94%|| 94/100 [03:05<00:08,  1.37s/it]Validating:  95%|| 95/100 [03:06<00:06,  1.38s/it]Validating:  96%|| 96/100 [03:08<00:05,  1.39s/it]Validating:  97%|| 97/100 [03:09<00:04,  1.38s/it]Validating:  98%|| 98/100 [03:11<00:02,  1.37s/it]Validating:  99%|| 99/100 [03:12<00:01,  1.36s/it]Validating: 100%|| 100/100 [03:13<00:00,  1.35s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:17<00:00,  1.98s/it]
SRCC0.922198715218067PLCC0.9318291919201247KRCC0.7659345657338335RMSE0.18090485460583486
{'val_n/best_SRCC-n': 0.9364377361555327, 'val_n/best_PLCC-n': 0.9378409865724974, 'val_n/best_KRCC-n': 0.7936312158108878, 'val_n/best_RMSE-n': 0.1727440342507699}
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:45<1:14:15, 45.00s/it]Validating:   2%|         | 2/100 [00:46<31:43, 19.42s/it]  Validating:   3%|         | 3/100 [00:48<18:09, 11.24s/it]Validating:   4%|         | 4/100 [00:49<11:51,  7.41s/it]Validating:   5%|         | 5/100 [00:51<08:20,  5.27s/it]Validating:   6%|         | 6/100 [00:52<06:16,  4.01s/it]Validating:   7%|         | 7/100 [00:54<04:56,  3.19s/it]Validating:   8%|         | 8/100 [00:55<04:04,  2.65s/it]Validating:   9%|         | 9/100 [00:57<03:28,  2.29s/it]Validating:  10%|         | 10/100 [00:58<03:05,  2.06s/it]Validating:  11%|         | 11/100 [01:00<02:50,  1.92s/it]Validating:  12%|        | 12/100 [01:01<02:38,  1.81s/it]Validating:  13%|        | 13/100 [01:03<02:30,  1.73s/it]Validating:  14%|        | 14/100 [01:04<02:23,  1.67s/it]Validating:  15%|        | 15/100 [01:06<02:19,  1.65s/it]Validating:  16%|        | 16/100 [01:08<02:15,  1.62s/it]Validating:  17%|        | 17/100 [01:09<02:14,  1.62s/it]Validating:  18%|        | 18/100 [01:11<02:15,  1.65s/it]Validating:  19%|        | 19/100 [01:13<02:14,  1.66s/it]Validating:  20%|        | 20/100 [01:14<02:12,  1.66s/it]Validating:  21%|        | 21/100 [01:16<02:11,  1.66s/it]Validating:  22%|       | 22/100 [01:18<02:09,  1.65s/it]Validating:  23%|       | 23/100 [01:19<02:05,  1.63s/it]Validating:  24%|       | 24/100 [01:21<02:02,  1.61s/it]Validating:  25%|       | 25/100 [01:22<01:59,  1.59s/it]Validating:  26%|       | 26/100 [01:24<01:55,  1.56s/it]Validating:  27%|       | 27/100 [01:25<01:52,  1.54s/it]Validating:  28%|       | 28/100 [01:27<01:50,  1.54s/it]Validating:  29%|       | 29/100 [01:28<01:48,  1.53s/it]Validating:  30%|       | 30/100 [01:30<01:46,  1.51s/it]Validating:  31%|       | 31/100 [01:31<01:44,  1.51s/it]Validating:  32%|      | 32/100 [01:33<01:41,  1.49s/it]Validating:  33%|      | 33/100 [01:34<01:39,  1.48s/it]Validating:  34%|      | 34/100 [01:36<01:38,  1.49s/it]Validating:  35%|      | 35/100 [01:37<01:37,  1.50s/it]Validating:  36%|      | 36/100 [01:39<01:36,  1.50s/it]Validating:  37%|      | 37/100 [01:40<01:34,  1.50s/it]Validating:  38%|      | 38/100 [01:42<01:33,  1.51s/it]Validating:  39%|      | 39/100 [01:43<01:33,  1.53s/it]Validating:  40%|      | 40/100 [01:45<01:34,  1.58s/it]Validating:  41%|      | 41/100 [01:47<01:37,  1.66s/it]Validating:  42%|     | 42/100 [01:49<01:37,  1.68s/it]Validating:  43%|     | 43/100 [01:50<01:35,  1.67s/it]Validating:  44%|     | 44/100 [01:52<01:32,  1.65s/it]Validating:  45%|     | 45/100 [01:53<01:29,  1.63s/it]Validating:  46%|     | 46/100 [01:55<01:24,  1.57s/it]Validating:  47%|     | 47/100 [01:56<01:22,  1.56s/it]Validating:  48%|     | 48/100 [01:58<01:19,  1.54s/it]Validating:  49%|     | 49/100 [01:59<01:17,  1.53s/it]Validating:  50%|     | 50/100 [02:01<01:16,  1.53s/it]Validating:  51%|     | 51/100 [02:02<01:14,  1.52s/it]Validating:  52%|    | 52/100 [02:04<01:13,  1.52s/it]Validating:  53%|    | 53/100 [02:05<01:12,  1.54s/it]Validating:  54%|    | 54/100 [02:07<01:10,  1.54s/it]Validating:  55%|    | 55/100 [02:09<01:10,  1.57s/it]Validating:  56%|    | 56/100 [02:10<01:10,  1.61s/it]Validating:  57%|    | 57/100 [02:12<01:09,  1.62s/it]Validating:  58%|    | 58/100 [02:14<01:08,  1.63s/it]Validating:  59%|    | 59/100 [02:15<01:05,  1.60s/it]Validating:  60%|    | 60/100 [02:17<01:03,  1.59s/it]Validating:  61%|    | 61/100 [02:18<01:00,  1.56s/it]Validating:  62%|   | 62/100 [02:20<00:58,  1.53s/it]Validating:  63%|   | 63/100 [02:21<00:56,  1.53s/it]Validating:  64%|   | 64/100 [02:23<00:54,  1.51s/it]Validating:  65%|   | 65/100 [02:24<00:52,  1.50s/it]Validating:  66%|   | 66/100 [02:26<00:51,  1.52s/it]Validating:  67%|   | 67/100 [02:27<00:50,  1.52s/it]Validating:  68%|   | 68/100 [02:29<00:48,  1.52s/it]Validating:  69%|   | 69/100 [02:30<00:46,  1.51s/it]Validating:  70%|   | 70/100 [02:32<00:45,  1.52s/it]Validating:  71%|   | 71/100 [02:33<00:44,  1.53s/it]Validating:  72%|  | 72/100 [02:35<00:43,  1.55s/it]Validating:  73%|  | 73/100 [02:36<00:41,  1.54s/it]Validating:  74%|  | 74/100 [02:38<00:39,  1.52s/it]Validating:  75%|  | 75/100 [02:39<00:37,  1.50s/it]Validating:  76%|  | 76/100 [02:41<00:36,  1.51s/it]Validating:  77%|  | 77/100 [02:42<00:34,  1.50s/it]Validating:  78%|  | 78/100 [02:44<00:32,  1.49s/it]Validating:  79%|  | 79/100 [02:45<00:31,  1.49s/it]Validating:  80%|  | 80/100 [02:47<00:29,  1.49s/it]Validating:  81%|  | 81/100 [02:48<00:28,  1.49s/it]Validating:  82%| | 82/100 [02:50<00:26,  1.49s/it]Validating:  83%| | 83/100 [02:51<00:25,  1.49s/it]Validating:  84%| | 84/100 [02:53<00:23,  1.49s/it]Validating:  85%| | 85/100 [02:54<00:22,  1.49s/it]Validating:  86%| | 86/100 [02:56<00:20,  1.49s/it]Validating:  87%| | 87/100 [02:57<00:19,  1.49s/it]Validating:  88%| | 88/100 [02:59<00:17,  1.49s/it]Validating:  89%| | 89/100 [03:00<00:16,  1.47s/it]Validating:  90%| | 90/100 [03:02<00:14,  1.46s/it]Validating:  91%| | 91/100 [03:03<00:13,  1.46s/it]Validating:  92%|| 92/100 [03:04<00:11,  1.45s/it]Validating:  93%|| 93/100 [03:06<00:10,  1.45s/it]Validating:  94%|| 94/100 [03:07<00:08,  1.45s/it]Validating:  95%|| 95/100 [03:09<00:07,  1.44s/it]Validating:  96%|| 96/100 [03:10<00:05,  1.44s/it]Validating:  97%|| 97/100 [03:12<00:04,  1.44s/it]Validating:  98%|| 98/100 [03:13<00:02,  1.44s/it]Validating:  99%|| 99/100 [03:15<00:01,  1.43s/it]Validating: 100%|| 100/100 [03:16<00:00,  1.44s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:20<00:00,  2.01s/it]
SRCC0.7958844325173263PLCC0.8068130548783679KRCC0.617676027086072RMSE0.30453688241672877
{'val_s/best_SRCC-s': 0.7958844325173263, 'val_s/best_PLCC-s': 0.8068130548783679, 'val_s/best_KRCC-s': 0.617676027086072, 'val_s/best_RMSE-s': 0.30453688241672877}
Epoch 2 completed. Average Loss: 0.07891729637049139

                the best validation accuracy of the model-s is as follows:
                SROCC: 0.9364
                PLCC:  0.9378
                KROCC: 0.7936
                RMSE:  0.1727.

                the best validation accuracy of the model-n is as follows:
                SROCC: 0.7959
                PLCC:  0.8068
                KROCC: 0.6177
                RMSE:  0.3045.
End-to-end Epoch 3:
Training in epoch 3:   0%|          | 0/25 [00:00<?, ?it/s]Training in epoch 3:   4%|         | 1/25 [01:13<29:31, 73.83s/it]Training in epoch 3:   8%|         | 2/25 [01:32<15:48, 41.22s/it]Training in epoch 3:  12%|        | 3/25 [01:50<11:14, 30.64s/it]Training in epoch 3:  16%|        | 4/25 [02:08<09:01, 25.81s/it]Training in epoch 3:  20%|        | 5/25 [02:26<07:38, 22.92s/it]Training in epoch 3:  24%|       | 6/25 [02:44<06:44, 21.29s/it]Training in epoch 3:  28%|       | 7/25 [03:03<06:09, 20.51s/it]Training in epoch 3:  32%|      | 8/25 [03:21<05:36, 19.79s/it]Training in epoch 3:  36%|      | 9/25 [03:40<05:10, 19.40s/it]Training in epoch 3:  40%|      | 10/25 [03:58<04:43, 18.90s/it]Training in epoch 3:  44%|     | 11/25 [04:15<04:19, 18.55s/it]Training in epoch 3:  48%|     | 12/25 [04:33<03:58, 18.38s/it]Training in epoch 3:  52%|    | 13/25 [04:52<03:40, 18.38s/it]Training in epoch 3:  56%|    | 14/25 [05:09<03:19, 18.14s/it]Training in epoch 3:  60%|    | 15/25 [05:27<02:59, 17.92s/it]Training in epoch 3:  64%|   | 16/25 [05:44<02:39, 17.74s/it]Training in epoch 3:  68%|   | 17/25 [06:02<02:22, 17.79s/it]Training in epoch 3:  72%|  | 18/25 [06:19<02:04, 17.72s/it]Training in epoch 3:  76%|  | 19/25 [06:37<01:45, 17.62s/it]Training in epoch 3:  80%|  | 20/25 [06:55<01:28, 17.63s/it]Training in epoch 3:  84%| | 21/25 [07:12<01:10, 17.60s/it]Training in epoch 3:  88%| | 22/25 [07:30<00:53, 17.67s/it]Training in epoch 3:  92%|| 23/25 [07:47<00:35, 17.65s/it]Training in epoch 3:  96%|| 24/25 [08:05<00:17, 17.54s/it]Training in epoch 3: 100%|| 25/25 [08:22<00:00, 17.52s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Training in epoch 3: 100%|| 25/25 [08:26<00:00, 20.27s/it]
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:43<1:10:58, 43.02s/it]Validating:   2%|         | 2/100 [00:44<30:17, 18.54s/it]  Validating:   3%|         | 3/100 [00:45<17:20, 10.73s/it]Validating:   4%|         | 4/100 [00:47<11:16,  7.05s/it]Validating:   5%|         | 5/100 [00:48<07:55,  5.00s/it]Validating:   6%|         | 6/100 [00:50<05:54,  3.77s/it]Validating:   7%|         | 7/100 [00:51<04:38,  3.00s/it]Validating:   8%|         | 8/100 [00:52<03:48,  2.48s/it]Validating:   9%|         | 9/100 [00:54<03:14,  2.14s/it]Validating:  10%|         | 10/100 [00:55<02:51,  1.91s/it]Validating:  11%|         | 11/100 [00:56<02:36,  1.76s/it]Validating:  12%|        | 12/100 [00:58<02:26,  1.66s/it]Validating:  13%|        | 13/100 [00:59<02:17,  1.59s/it]Validating:  14%|        | 14/100 [01:01<02:11,  1.53s/it]Validating:  15%|        | 15/100 [01:02<02:07,  1.50s/it]Validating:  16%|        | 16/100 [01:04<02:03,  1.47s/it]Validating:  17%|        | 17/100 [01:05<02:02,  1.48s/it]Validating:  18%|        | 18/100 [01:07<01:59,  1.46s/it]Validating:  19%|        | 19/100 [01:08<01:57,  1.45s/it]Validating:  20%|        | 20/100 [01:09<01:56,  1.46s/it]Validating:  21%|        | 21/100 [01:11<01:55,  1.46s/it]Validating:  22%|       | 22/100 [01:12<01:52,  1.44s/it]Validating:  23%|       | 23/100 [01:14<01:50,  1.44s/it]Validating:  24%|       | 24/100 [01:15<01:48,  1.43s/it]Validating:  25%|       | 25/100 [01:17<01:46,  1.43s/it]Validating:  26%|       | 26/100 [01:18<01:45,  1.42s/it]Validating:  27%|       | 27/100 [01:19<01:43,  1.42s/it]Validating:  28%|       | 28/100 [01:21<01:42,  1.42s/it]Validating:  29%|       | 29/100 [01:22<01:40,  1.42s/it]Validating:  30%|       | 30/100 [01:24<01:39,  1.42s/it]Validating:  31%|       | 31/100 [01:25<01:37,  1.42s/it]Validating:  32%|      | 32/100 [01:26<01:34,  1.39s/it]Validating:  33%|      | 33/100 [01:28<01:33,  1.39s/it]Validating:  34%|      | 34/100 [01:29<01:32,  1.40s/it]Validating:  35%|      | 35/100 [01:31<01:32,  1.42s/it]Validating:  36%|      | 36/100 [01:32<01:31,  1.44s/it]Validating:  37%|      | 37/100 [01:34<01:30,  1.43s/it]Validating:  38%|      | 38/100 [01:35<01:29,  1.44s/it]Validating:  39%|      | 39/100 [01:36<01:27,  1.44s/it]Validating:  40%|      | 40/100 [01:38<01:27,  1.46s/it]Validating:  41%|      | 41/100 [01:39<01:26,  1.46s/it]Validating:  42%|     | 42/100 [01:41<01:26,  1.49s/it]Validating:  43%|     | 43/100 [01:42<01:24,  1.47s/it]Validating:  44%|     | 44/100 [01:44<01:23,  1.48s/it]Validating:  45%|     | 45/100 [01:45<01:20,  1.47s/it]Validating:  46%|     | 46/100 [01:47<01:19,  1.47s/it]Validating:  47%|     | 47/100 [01:48<01:16,  1.45s/it]Validating:  48%|     | 48/100 [01:50<01:14,  1.43s/it]Validating:  49%|     | 49/100 [01:51<01:12,  1.41s/it]Validating:  50%|     | 50/100 [01:52<01:10,  1.41s/it]Validating:  51%|     | 51/100 [01:54<01:08,  1.41s/it]Validating:  52%|    | 52/100 [01:55<01:07,  1.41s/it]Validating:  53%|    | 53/100 [01:57<01:06,  1.42s/it]Validating:  54%|    | 54/100 [01:58<01:05,  1.43s/it]Validating:  55%|    | 55/100 [02:00<01:04,  1.44s/it]Validating:  56%|    | 56/100 [02:01<01:03,  1.44s/it]Validating:  57%|    | 57/100 [02:02<01:02,  1.45s/it]Validating:  58%|    | 58/100 [02:04<01:00,  1.44s/it]Validating:  59%|    | 59/100 [02:05<00:58,  1.42s/it]Validating:  60%|    | 60/100 [02:07<00:55,  1.40s/it]Validating:  61%|    | 61/100 [02:08<00:53,  1.38s/it]Validating:  62%|   | 62/100 [02:09<00:52,  1.37s/it]Validating:  63%|   | 63/100 [02:11<00:50,  1.37s/it]Validating:  64%|   | 64/100 [02:12<00:49,  1.36s/it]Validating:  65%|   | 65/100 [02:13<00:47,  1.36s/it]Validating:  66%|   | 66/100 [02:15<00:46,  1.37s/it]Validating:  67%|   | 67/100 [02:16<00:45,  1.38s/it]Validating:  68%|   | 68/100 [02:17<00:44,  1.38s/it]Validating:  69%|   | 69/100 [02:19<00:42,  1.38s/it]Validating:  70%|   | 70/100 [02:20<00:41,  1.38s/it]Validating:  71%|   | 71/100 [02:22<00:39,  1.37s/it]Validating:  72%|  | 72/100 [02:23<00:38,  1.38s/it]Validating:  73%|  | 73/100 [02:24<00:37,  1.38s/it]Validating:  74%|  | 74/100 [02:26<00:35,  1.38s/it]Validating:  75%|  | 75/100 [02:27<00:34,  1.38s/it]Validating:  76%|  | 76/100 [02:28<00:32,  1.37s/it]Validating:  77%|  | 77/100 [02:30<00:31,  1.37s/it]Validating:  78%|  | 78/100 [02:31<00:30,  1.37s/it]Validating:  79%|  | 79/100 [02:33<00:28,  1.37s/it]Validating:  80%|  | 80/100 [02:34<00:27,  1.37s/it]Validating:  81%|  | 81/100 [02:35<00:26,  1.37s/it]Validating:  82%| | 82/100 [02:37<00:24,  1.37s/it]Validating:  83%| | 83/100 [02:38<00:23,  1.37s/it]Validating:  84%| | 84/100 [02:39<00:21,  1.37s/it]Validating:  85%| | 85/100 [02:41<00:20,  1.38s/it]Validating:  86%| | 86/100 [02:42<00:19,  1.38s/it]Validating:  87%| | 87/100 [02:44<00:18,  1.39s/it]Validating:  88%| | 88/100 [02:45<00:16,  1.38s/it]Validating:  89%| | 89/100 [02:46<00:15,  1.38s/it]Validating:  90%| | 90/100 [02:48<00:13,  1.36s/it]Validating:  91%| | 91/100 [02:49<00:12,  1.35s/it]Validating:  92%|| 92/100 [02:50<00:10,  1.34s/it]Validating:  93%|| 93/100 [02:52<00:09,  1.34s/it]Validating:  94%|| 94/100 [02:53<00:07,  1.33s/it]Validating:  95%|| 95/100 [02:54<00:06,  1.33s/it]Validating:  96%|| 96/100 [02:56<00:05,  1.33s/it]Validating:  97%|| 97/100 [02:57<00:03,  1.33s/it]Validating:  98%|| 98/100 [02:58<00:02,  1.33s/it]Validating:  99%|| 99/100 [03:00<00:01,  1.33s/it]Validating: 100%|| 100/100 [03:01<00:00,  1.33s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:03<00:00,  1.84s/it]
SRCC0.9114414110359679PLCC0.9161110147008991KRCC0.7671564767666447RMSE0.20067971861547804
{'val_n/best_SRCC-n': 0.9364377361555327, 'val_n/best_PLCC-n': 0.9378409865724974, 'val_n/best_KRCC-n': 0.7936312158108878, 'val_n/best_RMSE-n': 0.1727440342507699}
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:40<1:06:14, 40.15s/it]Validating:   2%|         | 2/100 [00:41<28:27, 17.42s/it]  Validating:   3%|         | 3/100 [00:43<16:24, 10.15s/it]Validating:   4%|         | 4/100 [00:44<10:44,  6.72s/it]Validating:   5%|         | 5/100 [00:46<07:38,  4.82s/it]Validating:   6%|         | 6/100 [00:47<05:45,  3.68s/it]Validating:   7%|         | 7/100 [00:48<04:34,  2.95s/it]Validating:   8%|         | 8/100 [00:50<03:47,  2.47s/it]Validating:   9%|         | 9/100 [00:51<03:15,  2.15s/it]Validating:  10%|         | 10/100 [00:53<02:55,  1.95s/it]Validating:  11%|         | 11/100 [00:54<02:40,  1.80s/it]Validating:  12%|        | 12/100 [00:56<02:29,  1.70s/it]Validating:  13%|        | 13/100 [00:57<02:22,  1.64s/it]Validating:  14%|        | 14/100 [00:59<02:16,  1.58s/it]Validating:  15%|        | 15/100 [01:00<02:12,  1.55s/it]Validating:  16%|        | 16/100 [01:02<02:08,  1.53s/it]Validating:  17%|        | 17/100 [01:03<02:05,  1.52s/it]Validating:  18%|        | 18/100 [01:05<02:04,  1.52s/it]Validating:  19%|        | 19/100 [01:06<02:03,  1.52s/it]Validating:  20%|        | 20/100 [01:08<02:01,  1.52s/it]Validating:  21%|        | 21/100 [01:09<02:00,  1.52s/it]Validating:  22%|       | 22/100 [01:11<01:57,  1.51s/it]Validating:  23%|       | 23/100 [01:12<01:55,  1.50s/it]Validating:  24%|       | 24/100 [01:14<01:54,  1.50s/it]Validating:  25%|       | 25/100 [01:15<01:52,  1.50s/it]Validating:  26%|       | 26/100 [01:17<01:50,  1.50s/it]Validating:  27%|       | 27/100 [01:18<01:48,  1.49s/it]Validating:  28%|       | 28/100 [01:20<01:47,  1.49s/it]Validating:  29%|       | 29/100 [01:21<01:45,  1.49s/it]Validating:  30%|       | 30/100 [01:23<01:43,  1.48s/it]Validating:  31%|       | 31/100 [01:24<01:42,  1.49s/it]Validating:  32%|      | 32/100 [01:26<01:38,  1.45s/it]Validating:  33%|      | 33/100 [01:27<01:36,  1.44s/it]Validating:  34%|      | 34/100 [01:28<01:36,  1.46s/it]Validating:  35%|      | 35/100 [01:30<01:36,  1.48s/it]Validating:  36%|      | 36/100 [01:31<01:34,  1.48s/it]Validating:  37%|      | 37/100 [01:33<01:33,  1.48s/it]Validating:  38%|      | 38/100 [01:34<01:32,  1.49s/it]Validating:  39%|      | 39/100 [01:36<01:31,  1.49s/it]Validating:  40%|      | 40/100 [01:38<01:30,  1.50s/it]Validating:  41%|      | 41/100 [01:39<01:29,  1.51s/it]Validating:  42%|     | 42/100 [01:41<01:28,  1.53s/it]Validating:  43%|     | 43/100 [01:42<01:26,  1.53s/it]Validating:  44%|     | 44/100 [01:44<01:24,  1.51s/it]Validating:  45%|     | 45/100 [01:45<01:22,  1.50s/it]Validating:  46%|     | 46/100 [01:47<01:19,  1.48s/it]Validating:  47%|     | 47/100 [01:48<01:18,  1.48s/it]Validating:  48%|     | 48/100 [01:49<01:16,  1.48s/it]Validating:  49%|     | 49/100 [01:51<01:14,  1.47s/it]Validating:  50%|     | 50/100 [01:52<01:12,  1.46s/it]Validating:  51%|     | 51/100 [01:54<01:11,  1.46s/it]Validating:  52%|    | 52/100 [01:55<01:10,  1.47s/it]Validating:  53%|    | 53/100 [01:57<01:09,  1.48s/it]Validating:  54%|    | 54/100 [01:58<01:08,  1.50s/it]Validating:  55%|    | 55/100 [02:00<01:07,  1.50s/it]Validating:  56%|    | 56/100 [02:01<01:06,  1.50s/it]Validating:  57%|    | 57/100 [02:03<01:04,  1.51s/it]Validating:  58%|    | 58/100 [02:04<01:03,  1.51s/it]Validating:  59%|    | 59/100 [02:06<01:01,  1.49s/it]Validating:  60%|    | 60/100 [02:07<00:58,  1.47s/it]Validating:  61%|    | 61/100 [02:09<00:56,  1.46s/it]Validating:  62%|   | 62/100 [02:10<00:55,  1.45s/it]Validating:  63%|   | 63/100 [02:12<00:53,  1.45s/it]Validating:  64%|   | 64/100 [02:13<00:51,  1.44s/it]Validating:  65%|   | 65/100 [02:14<00:50,  1.44s/it]Validating:  66%|   | 66/100 [02:16<00:49,  1.45s/it]Validating:  67%|   | 67/100 [02:17<00:48,  1.46s/it]Validating:  68%|   | 68/100 [02:19<00:46,  1.47s/it]Validating:  69%|   | 69/100 [02:20<00:45,  1.47s/it]Validating:  70%|   | 70/100 [02:22<00:44,  1.47s/it]Validating:  71%|   | 71/100 [02:23<00:42,  1.46s/it]Validating:  72%|  | 72/100 [02:25<00:40,  1.46s/it]Validating:  73%|  | 73/100 [02:26<00:39,  1.46s/it]Validating:  74%|  | 74/100 [02:28<00:37,  1.46s/it]Validating:  75%|  | 75/100 [02:29<00:36,  1.46s/it]Validating:  76%|  | 76/100 [02:31<00:34,  1.45s/it]Validating:  77%|  | 77/100 [02:32<00:33,  1.46s/it]Validating:  78%|  | 78/100 [02:33<00:32,  1.45s/it]Validating:  79%|  | 79/100 [02:35<00:30,  1.45s/it]Validating:  80%|  | 80/100 [02:36<00:28,  1.45s/it]Validating:  81%|  | 81/100 [02:38<00:27,  1.45s/it]Validating:  82%| | 82/100 [02:39<00:26,  1.45s/it]Validating:  83%| | 83/100 [02:41<00:24,  1.45s/it]Validating:  84%| | 84/100 [02:42<00:23,  1.45s/it]Validating:  85%| | 85/100 [02:44<00:21,  1.45s/it]Validating:  86%| | 86/100 [02:45<00:20,  1.45s/it]Validating:  87%| | 87/100 [02:46<00:18,  1.45s/it]Validating:  88%| | 88/100 [02:48<00:17,  1.46s/it]Validating:  89%| | 89/100 [02:49<00:15,  1.44s/it]Validating:  90%| | 90/100 [02:51<00:14,  1.45s/it]Validating:  91%| | 91/100 [02:52<00:13,  1.47s/it]Validating:  92%|| 92/100 [02:54<00:11,  1.46s/it]Validating:  93%|| 93/100 [02:55<00:10,  1.45s/it]Validating:  94%|| 94/100 [02:57<00:08,  1.45s/it]Validating:  95%|| 95/100 [02:58<00:07,  1.44s/it]Validating:  96%|| 96/100 [03:00<00:05,  1.44s/it]Validating:  97%|| 97/100 [03:01<00:04,  1.43s/it]Validating:  98%|| 98/100 [03:02<00:02,  1.43s/it]Validating:  99%|| 99/100 [03:04<00:01,  1.43s/it]Validating: 100%|| 100/100 [03:05<00:00,  1.43s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:08<00:00,  1.88s/it]
SRCC0.8008488803736856PLCC0.8090696225590384KRCC0.6193052417964869RMSE0.302753049435848
{'val_s/best_SRCC-s': 0.8008488803736856, 'val_s/best_PLCC-s': 0.8090696225590384, 'val_s/best_KRCC-s': 0.6193052417964869, 'val_s/best_RMSE-s': 0.302753049435848}
Epoch 3 completed. Average Loss: 0.06874300501891412

                the best validation accuracy of the model-s is as follows:
                SROCC: 0.9364
                PLCC:  0.9378
                KROCC: 0.7936
                RMSE:  0.1727.

                the best validation accuracy of the model-n is as follows:
                SROCC: 0.8008
                PLCC:  0.8091
                KROCC: 0.6193
                RMSE:  0.3028.
End-to-end Epoch 4:
Training in epoch 4:   0%|          | 0/25 [00:00<?, ?it/s]Training in epoch 4:   4%|         | 1/25 [01:13<29:28, 73.68s/it]Training in epoch 4:   8%|         | 2/25 [01:32<15:46, 41.13s/it]Training in epoch 4:  12%|        | 3/25 [01:51<11:28, 31.31s/it]Training in epoch 4:  16%|        | 4/25 [02:10<09:10, 26.23s/it]Training in epoch 4:  20%|        | 5/25 [02:29<07:56, 23.84s/it]Training in epoch 4:  24%|       | 6/25 [02:47<06:56, 21.90s/it]Training in epoch 4:  28%|       | 7/25 [03:06<06:14, 20.80s/it]Training in epoch 4:  32%|      | 8/25 [03:25<05:43, 20.18s/it]Training in epoch 4:  36%|      | 9/25 [03:43<05:13, 19.62s/it]Training in epoch 4:  40%|      | 10/25 [04:01<04:48, 19.21s/it]Training in epoch 4:  44%|     | 11/25 [04:20<04:25, 19.00s/it]Training in epoch 4:  48%|     | 12/25 [04:40<04:09, 19.20s/it]Training in epoch 4:  52%|    | 13/25 [04:59<03:49, 19.16s/it]Training in epoch 4:  56%|    | 14/25 [05:17<03:28, 18.94s/it]Training in epoch 4:  60%|    | 15/25 [05:35<03:05, 18.58s/it]Training in epoch 4:  64%|   | 16/25 [05:53<02:45, 18.35s/it]Training in epoch 4:  68%|   | 17/25 [06:10<02:24, 18.11s/it]Training in epoch 4:  72%|  | 18/25 [06:28<02:05, 17.92s/it]Training in epoch 4:  76%|  | 19/25 [06:45<01:46, 17.76s/it]Training in epoch 4:  80%|  | 20/25 [07:03<01:28, 17.67s/it]Training in epoch 4:  84%| | 21/25 [07:20<01:10, 17.56s/it]Training in epoch 4:  88%| | 22/25 [07:37<00:52, 17.54s/it]Training in epoch 4:  92%|| 23/25 [07:55<00:35, 17.50s/it]Training in epoch 4:  96%|| 24/25 [08:12<00:17, 17.41s/it]Training in epoch 4: 100%|| 25/25 [08:29<00:00, 17.41s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Training in epoch 4: 100%|| 25/25 [08:34<00:00, 20.57s/it]
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:44<1:13:45, 44.70s/it]Validating:   2%|         | 2/100 [00:46<31:30, 19.30s/it]  Validating:   3%|         | 3/100 [00:47<17:58, 11.12s/it]Validating:   4%|         | 4/100 [00:48<11:38,  7.28s/it]Validating:   5%|         | 5/100 [00:50<08:09,  5.16s/it]Validating:   6%|         | 6/100 [00:51<06:03,  3.87s/it]Validating:   7%|         | 7/100 [00:53<04:44,  3.06s/it]Validating:   8%|         | 8/100 [00:54<03:52,  2.53s/it]Validating:   9%|         | 9/100 [00:55<03:17,  2.17s/it]Validating:  10%|         | 10/100 [00:57<02:53,  1.93s/it]Validating:  11%|         | 11/100 [00:58<02:36,  1.76s/it]Validating:  12%|        | 12/100 [01:00<02:24,  1.64s/it]Validating:  13%|        | 13/100 [01:01<02:17,  1.58s/it]Validating:  14%|        | 14/100 [01:02<02:11,  1.53s/it]Validating:  15%|        | 15/100 [01:04<02:06,  1.49s/it]Validating:  16%|        | 16/100 [01:05<02:03,  1.47s/it]Validating:  17%|        | 17/100 [01:07<02:01,  1.46s/it]Validating:  18%|        | 18/100 [01:08<01:58,  1.44s/it]Validating:  19%|        | 19/100 [01:10<01:56,  1.44s/it]Validating:  20%|        | 20/100 [01:11<01:55,  1.44s/it]Validating:  21%|        | 21/100 [01:12<01:53,  1.44s/it]Validating:  22%|       | 22/100 [01:14<01:52,  1.45s/it]Validating:  23%|       | 23/100 [01:15<01:51,  1.45s/it]Validating:  24%|       | 24/100 [01:17<01:48,  1.43s/it]Validating:  25%|       | 25/100 [01:18<01:47,  1.43s/it]Validating:  26%|       | 26/100 [01:20<01:45,  1.42s/it]Validating:  27%|       | 27/100 [01:21<01:43,  1.42s/it]Validating:  28%|       | 28/100 [01:22<01:41,  1.41s/it]Validating:  29%|       | 29/100 [01:24<01:40,  1.41s/it]Validating:  30%|       | 30/100 [01:25<01:38,  1.41s/it]Validating:  31%|       | 31/100 [01:27<01:37,  1.41s/it]Validating:  32%|      | 32/100 [01:28<01:34,  1.39s/it]Validating:  33%|      | 33/100 [01:29<01:33,  1.39s/it]Validating:  34%|      | 34/100 [01:31<01:31,  1.39s/it]Validating:  35%|      | 35/100 [01:32<01:30,  1.39s/it]Validating:  36%|      | 36/100 [01:33<01:29,  1.39s/it]Validating:  37%|      | 37/100 [01:35<01:28,  1.40s/it]Validating:  38%|      | 38/100 [01:36<01:27,  1.42s/it]Validating:  39%|      | 39/100 [01:38<01:26,  1.41s/it]Validating:  40%|      | 40/100 [01:39<01:25,  1.42s/it]Validating:  41%|      | 41/100 [01:41<01:24,  1.43s/it]Validating:  42%|     | 42/100 [01:42<01:23,  1.44s/it]Validating:  43%|     | 43/100 [01:44<01:21,  1.44s/it]Validating:  44%|     | 44/100 [01:45<01:20,  1.44s/it]Validating:  45%|     | 45/100 [01:46<01:17,  1.42s/it]Validating:  46%|     | 46/100 [01:48<01:15,  1.40s/it]Validating:  47%|     | 47/100 [01:49<01:13,  1.40s/it]Validating:  48%|     | 48/100 [01:50<01:12,  1.39s/it]Validating:  49%|     | 49/100 [01:52<01:10,  1.38s/it]Validating:  50%|     | 50/100 [01:53<01:08,  1.38s/it]Validating:  51%|     | 51/100 [01:55<01:07,  1.37s/it]Validating:  52%|    | 52/100 [01:56<01:06,  1.39s/it]Validating:  53%|    | 53/100 [01:57<01:05,  1.40s/it]Validating:  54%|    | 54/100 [01:59<01:05,  1.42s/it]Validating:  55%|    | 55/100 [02:00<01:04,  1.43s/it]Validating:  56%|    | 56/100 [02:02<01:02,  1.43s/it]Validating:  57%|    | 57/100 [02:03<01:01,  1.44s/it]Validating:  58%|    | 58/100 [02:05<01:00,  1.43s/it]Validating:  59%|    | 59/100 [02:06<00:57,  1.41s/it]Validating:  60%|    | 60/100 [02:07<00:55,  1.39s/it]Validating:  61%|    | 61/100 [02:09<00:53,  1.38s/it]Validating:  62%|   | 62/100 [02:10<00:52,  1.37s/it]Validating:  63%|   | 63/100 [02:11<00:50,  1.37s/it]Validating:  64%|   | 64/100 [02:13<00:49,  1.38s/it]Validating:  65%|   | 65/100 [02:14<00:48,  1.39s/it]Validating:  66%|   | 66/100 [02:16<00:47,  1.40s/it]Validating:  67%|   | 67/100 [02:17<00:46,  1.40s/it]Validating:  68%|   | 68/100 [02:18<00:44,  1.38s/it]Validating:  69%|   | 69/100 [02:20<00:42,  1.37s/it]Validating:  70%|   | 70/100 [02:21<00:40,  1.34s/it]Validating:  71%|   | 71/100 [02:22<00:38,  1.34s/it]Validating:  72%|  | 72/100 [02:24<00:37,  1.34s/it]Validating:  73%|  | 73/100 [02:25<00:36,  1.34s/it]Validating:  74%|  | 74/100 [02:26<00:34,  1.32s/it]Validating:  75%|  | 75/100 [02:28<00:32,  1.30s/it]Validating:  76%|  | 76/100 [02:29<00:30,  1.28s/it]Validating:  77%|  | 77/100 [02:30<00:29,  1.26s/it]Validating:  78%|  | 78/100 [02:31<00:27,  1.25s/it]Validating:  79%|  | 79/100 [02:32<00:25,  1.24s/it]Validating:  80%|  | 80/100 [02:34<00:24,  1.23s/it]Validating:  81%|  | 81/100 [02:35<00:23,  1.22s/it]Validating:  82%| | 82/100 [02:36<00:21,  1.22s/it]Validating:  83%| | 83/100 [02:37<00:20,  1.21s/it]Validating:  84%| | 84/100 [02:38<00:19,  1.21s/it]Validating:  85%| | 85/100 [02:40<00:18,  1.21s/it]Validating:  86%| | 86/100 [02:41<00:16,  1.21s/it]Validating:  87%| | 87/100 [02:42<00:15,  1.21s/it]Validating:  88%| | 88/100 [02:43<00:14,  1.21s/it]Validating:  89%| | 89/100 [02:44<00:13,  1.20s/it]Validating:  90%| | 90/100 [02:46<00:11,  1.19s/it]Validating:  91%| | 91/100 [02:47<00:10,  1.19s/it]Validating:  92%|| 92/100 [02:48<00:09,  1.19s/it]Validating:  93%|| 93/100 [02:49<00:08,  1.18s/it]Validating:  94%|| 94/100 [02:50<00:07,  1.18s/it]Validating:  95%|| 95/100 [02:52<00:05,  1.18s/it]Validating:  96%|| 96/100 [02:53<00:04,  1.18s/it]Validating:  97%|| 97/100 [02:54<00:03,  1.18s/it]Validating:  98%|| 98/100 [02:55<00:02,  1.18s/it]Validating:  99%|| 99/100 [02:56<00:01,  1.18s/it]Validating: 100%|| 100/100 [02:57<00:00,  1.18s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [03:00<00:00,  1.81s/it]
SRCC0.9139566512437242PLCC0.9184398954295807KRCC0.7651199583786259RMSE0.19787453369530317
{'val_n/best_SRCC-n': 0.9364377361555327, 'val_n/best_PLCC-n': 0.9378409865724974, 'val_n/best_KRCC-n': 0.7936312158108878, 'val_n/best_RMSE-n': 0.1727440342507699}
Validating:   0%|          | 0/100 [00:00<?, ?it/s]Validating:   1%|          | 1/100 [00:38<1:02:58, 38.17s/it]Validating:   2%|         | 2/100 [00:39<26:55, 16.49s/it]  Validating:   3%|         | 3/100 [00:40<15:25,  9.55s/it]Validating:   4%|         | 4/100 [00:42<10:03,  6.29s/it]Validating:   5%|         | 5/100 [00:43<07:05,  4.48s/it]Validating:   6%|         | 6/100 [00:44<05:19,  3.39s/it]Validating:   7%|         | 7/100 [00:45<04:11,  2.71s/it]Validating:   8%|         | 8/100 [00:47<03:27,  2.25s/it]Validating:   9%|         | 9/100 [00:48<02:56,  1.94s/it]Validating:  10%|         | 10/100 [00:49<02:37,  1.75s/it]Validating:  11%|         | 11/100 [00:51<02:23,  1.61s/it]Validating:  12%|        | 12/100 [00:52<02:13,  1.52s/it]Validating:  13%|        | 13/100 [00:53<02:06,  1.45s/it]Validating:  14%|        | 14/100 [00:54<02:01,  1.41s/it]Validating:  15%|        | 15/100 [00:56<01:57,  1.38s/it]Validating:  16%|        | 16/100 [00:57<01:53,  1.36s/it]Validating:  17%|        | 17/100 [00:58<01:52,  1.36s/it]Validating:  18%|        | 18/100 [01:00<01:52,  1.37s/it]Validating:  19%|        | 19/100 [01:01<01:50,  1.37s/it]Validating:  20%|        | 20/100 [01:03<01:48,  1.36s/it]Validating:  21%|        | 21/100 [01:04<01:47,  1.36s/it]Validating:  22%|       | 22/100 [01:05<01:45,  1.35s/it]Validating:  23%|       | 23/100 [01:07<01:43,  1.34s/it]Validating:  24%|       | 24/100 [01:08<01:41,  1.33s/it]Validating:  25%|       | 25/100 [01:09<01:39,  1.32s/it]Validating:  26%|       | 26/100 [01:10<01:37,  1.32s/it]Validating:  27%|       | 27/100 [01:12<01:36,  1.32s/it]Validating:  28%|       | 28/100 [01:13<01:34,  1.31s/it]Validating:  29%|       | 29/100 [01:14<01:32,  1.31s/it]Validating:  30%|       | 30/100 [01:16<01:31,  1.30s/it]Validating:  31%|       | 31/100 [01:17<01:29,  1.30s/it]Validating:  32%|      | 32/100 [01:18<01:29,  1.32s/it]Validating:  33%|      | 33/100 [01:20<01:28,  1.32s/it]Validating:  34%|      | 34/100 [01:21<01:27,  1.33s/it]Validating:  35%|      | 35/100 [01:22<01:26,  1.33s/it]Validating:  36%|      | 36/100 [01:24<01:24,  1.32s/it]Validating:  37%|      | 37/100 [01:25<01:23,  1.32s/it]Validating:  38%|      | 38/100 [01:26<01:22,  1.33s/it]Validating:  39%|      | 39/100 [01:28<01:21,  1.33s/it]Validating:  40%|      | 40/100 [01:29<01:20,  1.33s/it]Validating:  41%|      | 41/100 [01:30<01:18,  1.34s/it]Validating:  42%|     | 42/100 [01:32<01:18,  1.35s/it]Validating:  43%|     | 43/100 [01:33<01:16,  1.35s/it]Validating:  44%|     | 44/100 [01:34<01:15,  1.35s/it]Validating:  45%|     | 45/100 [01:36<01:13,  1.33s/it]Validating:  46%|     | 46/100 [01:37<01:11,  1.32s/it]Validating:  47%|     | 47/100 [01:38<01:09,  1.31s/it]Validating:  48%|     | 48/100 [01:40<01:07,  1.30s/it]Validating:  49%|     | 49/100 [01:41<01:05,  1.29s/it]Validating:  50%|     | 50/100 [01:42<01:04,  1.29s/it]Validating:  51%|     | 51/100 [01:43<01:02,  1.29s/it]Validating:  52%|    | 52/100 [01:45<01:02,  1.29s/it]Validating:  53%|    | 53/100 [01:46<01:01,  1.30s/it]Validating:  54%|    | 54/100 [01:47<01:00,  1.31s/it]Validating:  55%|    | 55/100 [01:49<00:59,  1.32s/it]Validating:  56%|    | 56/100 [01:50<00:58,  1.32s/it]Validating:  57%|    | 57/100 [01:51<00:56,  1.32s/it]Validating:  58%|    | 58/100 [01:53<00:55,  1.32s/it]Validating:  59%|    | 59/100 [01:54<00:53,  1.30s/it]Validating:  60%|    | 60/100 [01:55<00:51,  1.29s/it]Validating:  61%|    | 61/100 [01:56<00:50,  1.28s/it]Validating:  62%|   | 62/100 [01:58<00:48,  1.28s/it]Validating:  63%|   | 63/100 [01:59<00:47,  1.27s/it]Validating:  64%|   | 64/100 [02:00<00:45,  1.27s/it]Validating:  65%|   | 65/100 [02:01<00:44,  1.27s/it]Validating:  66%|   | 66/100 [02:03<00:43,  1.28s/it]Validating:  67%|   | 67/100 [02:04<00:42,  1.28s/it]Validating:  68%|   | 68/100 [02:05<00:41,  1.28s/it]Validating:  69%|   | 69/100 [02:07<00:39,  1.28s/it]Validating:  70%|   | 70/100 [02:08<00:38,  1.28s/it]Validating:  71%|   | 71/100 [02:09<00:37,  1.28s/it]Validating:  72%|  | 72/100 [02:11<00:35,  1.28s/it]Validating:  73%|  | 73/100 [02:12<00:34,  1.28s/it]Validating:  74%|  | 74/100 [02:13<00:33,  1.28s/it]Validating:  75%|  | 75/100 [02:14<00:32,  1.29s/it]Validating:  76%|  | 76/100 [02:16<00:30,  1.29s/it]Validating:  77%|  | 77/100 [02:17<00:29,  1.29s/it]Validating:  78%|  | 78/100 [02:18<00:28,  1.28s/it]Validating:  79%|  | 79/100 [02:19<00:26,  1.28s/it]Validating:  80%|  | 80/100 [02:21<00:25,  1.28s/it]Validating:  81%|  | 81/100 [02:22<00:24,  1.28s/it]Validating:  82%| | 82/100 [02:23<00:22,  1.28s/it]Validating:  83%| | 83/100 [02:25<00:21,  1.28s/it]Validating:  84%| | 84/100 [02:26<00:20,  1.27s/it]Validating:  85%| | 85/100 [02:27<00:19,  1.28s/it]Validating:  86%| | 86/100 [02:28<00:17,  1.27s/it]Validating:  87%| | 87/100 [02:30<00:16,  1.28s/it]Validating:  88%| | 88/100 [02:31<00:15,  1.28s/it]Validating:  89%| | 89/100 [02:32<00:13,  1.27s/it]Validating:  90%| | 90/100 [02:33<00:12,  1.26s/it]Validating:  91%| | 91/100 [02:35<00:11,  1.26s/it]Validating:  92%|| 92/100 [02:36<00:10,  1.25s/it]Validating:  93%|| 93/100 [02:37<00:08,  1.25s/it]Validating:  94%|| 94/100 [02:38<00:07,  1.25s/it]Validating:  95%|| 95/100 [02:40<00:06,  1.25s/it]Validating:  96%|| 96/100 [02:41<00:04,  1.25s/it]Validating:  97%|| 97/100 [02:42<00:03,  1.25s/it]Validating:  98%|| 98/100 [02:43<00:02,  1.25s/it]Validating:  99%|| 99/100 [02:45<00:01,  1.24s/it]Validating: 100%|| 100/100 [02:46<00:00,  1.24s/it]pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
pretrained_weights/swin_tiny_patch244_window877_kinetics400_1k.pth False
loading swin lah
load swin from kk: _IncompatibleKeys(missing_keys=[], unexpected_keys=['layers.3.blocks.0.attn.fragment_position_bias_table', 'layers.3.blocks.1.attn.fragment_position_bias_table'])
C:\Users\16047\.conda\envs\KVQ\lib\site-packages\torch\functional.py:513: UserWarning: torch.meshgrid: in an upcoming release, it will be required to pass the indexing argument. (Triggered internally at C:\actions-runner\_work\pytorch\pytorch\builder\windows\pytorch\aten\src\ATen\native\TensorShape.cpp:3610.)
  return _VF.meshgrid(tensors, **kwargs)  # type: ignore[attr-defined]
C:\Project\kvq2\kvq\models\backbones\swin_backbone.py:938: FutureWarning: You are using `torch.load` with `weights_only=False` (the current default value), which uses the default pickle module implicitly. It is possible to construct malicious pickle data which will execute arbitrary code during unpickling (See https://github.com/pytorch/pytorch/blob/main/SECURITY.md#untrusted-models for more details). In a future release, the default value for `weights_only` will be flipped to `True`. This limits the functions that could be executed during unpickling. Arbitrary objects will no longer be allowed to be loaded via this mode unless they are explicitly allowlisted by the user via `torch.serialization.add_safe_globals`. We recommend you start setting `weights_only=True` for any use case where you don't have full control of the loaded file. Please open an issue on GitHub for any issues related to this experimental feature.
  state_dict = torch.load(load_path)["state_dict"]
Validating: 100%|| 100/100 [02:48<00:00,  1.69s/it]
SRCC0.802469679552908PLCC0.8126102451245476KRCC0.6197125454740907RMSE0.29993276869907454
{'val_s/best_SRCC-s': 0.802469679552908, 'val_s/best_PLCC-s': 0.8126102451245476, 'val_s/best_KRCC-s': 0.6197125454740907, 'val_s/best_RMSE-s': 0.29993276869907454}
Epoch 4 completed. Average Loss: 0.03693303965264931

                the best validation accuracy of the model-s is as follows:
                SROCC: 0.9364
                PLCC:  0.9378
                KROCC: 0.7936
                RMSE:  0.1727.

                the best validation accuracy of the model-n is as follows:
                SROCC: 0.8025
                PLCC:  0.8126
                KROCC: 0.6197
                RMSE:  0.2999.
